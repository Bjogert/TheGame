# ai_memory.V.1.yaml
version: 1
project: "medieval_sim"
updated_utc: "2025-10-22T12:30:00Z"

# Short-term notes are tied to the active step. Promote durable lessons to long_term.
short_term:
  - step: "S0.1a"
    decisions:
      - "Standard toolchain is rustc 1.90.0 (stable); rustfmt and clippy installed via rustup."
      - "Continue targeting Bevy 0.17; document if a custom toolchain becomes necessary."
    risks:
      - "Pre-release Bevy minor may shift APIs; lock patch version once crates stabilise."
      - "Running cargo run in unattended sessions can hang until the window is closed; note manual close requirement."
      - "WGPU warns about missing Vulkan validation layers on Windows; harmless but worth tracking if debug tooling is needed."
    experiments:
      - "Evaluate whether evy::time::Time<Virtual> satisfies scaling needs before rolling a custom resource."
      - "cargo clippy requires the -- -D warnings invocation to propagate deny rules."
    open_questions:
      - "Should we adopt leafwing_input_manager before implementing first-person controls (M1)?"
      - "Will SQLite be used directly (rusqlite) or via higher-level crate (sqlx)?"
  - step: "S0.1b"
    decisions:
      - "Implemented custom SimulationClock resource over Bevy Time<Virtual> to keep control of clamping/logging."
      - "Retained set_time_scale with conditional dead code allowance until config wiring lands."
      - "Startup system logs configured scale to aid debugging."
    risks:
      - "SimulationClock must stay in sync with Bevy time; consider instrumentation if divergence occurs."
      - "#[allow(dead_code)] on SimulationClock accessors should be revisited once time scaling config is live."
    experiments:
      - "Unit tests verify scaling and clamping; consider property tests later for edge cases."
    open_questions:
      - "When wiring /config/time.toml, should we support live changes or only startup loads?"
  - step: "S0.1c"
    decisions:
      - "Added cargo feature core_debug to gate per-second logging without affecting release binaries."
      - "Implemented repeating timer using SimulationClock scaled deltas to report elapsed sim time and deltas."
      - "Updated VS Code tasks to pass -- -D warnings to Clippy and surface feature-aware run targets."
    risks:
      - "Logging every second is helpful for debugging but still noisy; document clearly and keep feature off by default."
      - "#[allow(dead_code)] guards on SimulationClock accessors should be removed once world systems consume them."
    experiments:
      - "Tested cargo clippy with and without core_debug feature to ensure gating works."
    open_questions:
      - "Should we add structured logging (e.g., tracing spans) instead of plain info! for debug output?"
      - "Is Bevy's diagnostic plugin sufficient for FPS/entity counts, or do we craft custom metrics?"
  - step: "S0.2a"
    decisions:
      - "Adopted fly camera controls matching Bevy 0.17 input APIs (ButtonInput, MessageReader)."
      - "Kept ground to a scalable Plane3d mesh to simplify future terrain swaps."
    risks:
      - "Scene scaffolding can balloon quickly; keep placeholder assets lightweight to avoid perf surprises."
    experiments: []
    open_questions:
      - "Use primitive meshes or quick GLTF placeholders for ground/NPCs during S0.2a?"
  - step: "S0.2b"
    decisions:
      - "WorldTimeSettings loads from config/time.toml with fallback logging."
      - "WorldClock derives from SimulationClock so global time scaling propagates automatically."
      - "PrimarySun lighting and ambient color lerp based on the clock."
    risks:
      - "Lighting curve is simplistic; may need refinement when weather/skybox arrive."
      - "Config reload is static; consider hot-reload before exposing to players."
    experiments:
      - "Verified cargo clippy with and without core_debug to ensure conditional compilation works."
    open_questions:
      - "Should we surface time-of-day to UI/console for debugging?"
      - "Do we need season-aware parameters (e.g., multiple declinations) before weather work?"
  - step: "S0.3a"
    decisions:
      - "Documentation sweep captured world time guidance across README, tech notes, and architecture snapshot."
      - "Planning artifacts updated to make S1.1a the next active step."
    risks:
      - "Documentation can drift quickly; review at the start of each milestone."
    experiments: []
    open_questions:
      - "Should we add automated checks (spellcheck, linkcheck) before milestone S1?"
  - step: "S1.1b"
    decisions:
      - "Introduced ScheduleTicker to accumulate simulation time (default 5s) before updating NPC activities."
      - "Collapsed schedule processing into a single tick system to avoid ordering issues."
    risks:
      - "Tick interval is hard-coded; scheduling cadence should become configurable later."
    experiments: []
    open_questions:
      - "Do we need per-NPC tick overrides (e.g., more/less reactive characters)?"
  - step: "S1.2"
    decisions:
      - "Documented dialogue provider options and rate limiting plan."
      - "Outlined prompt scaffolding requirements and identified missing simulation data."
    risks:
      - "Vendor pricing/availability may shift; keep broker abstraction flexible."
    experiments: []
    open_questions:
      - "Which provider should we prototype first (OpenAI vs Anthropic vs local)?"
  - step: "S1.3"
    decisions:
      - "Implemented DialoguePlugin with LocalDialogueBroker, queue resources, and rate limiting timers."
      - "Structured dialogue context to include trade descriptors and schedule updates ahead of LLM integration."
    risks:
      - "Current cooldown/backoff values are placeholders; real providers may require dynamic throttling."
      - "Local broker responses are deterministic stubs; integration gaps could appear when swapping to real APIs."
    experiments: []
    open_questions:
      - "How should we persist recent dialogue context so providers can reference multi-turn exchanges?"
      - "Where will provider authentication/configuration live once remote services are wired up?"
  - step: "S1.4"
    decisions:
      - "Daily trade loop runs after the world clock tick to keep exchanges aligned with simulation days."
      - "Trade events immediately enqueue dialogue requests so conversation timing mirrors economic activity."
      - "Deliveries verify both courier and recipient reach their crates before completing so inventory transfers stay grounded in the scene."
    risks:
      - "Placeholder goods and static participants will need replacement before scaling to larger populations."
      - "Inventory logic is minimal; concurrency issues may arise once multiple systems mutate stock."
      - "Hosted container lacks wayland-client development libs, so cargo clippy/check fail until pkg-config can locate the system headers."
    experiments: []
    open_questions:
      - "Should trade history be summarised per NPC for later prompt compression?"
      - "How do we generalise the loop to support deliveries that span multiple ticks or locations?"
  - step: "S1.5"
    decisions:
      - "Economy foundations will revolve around an EconomyRegistry loading profession/recipe data from TOML configs."
      - "WorkOrderQueue becomes the bridge between economy production plans and NPC schedule claims."
      - "Economy events will be split into production/transfer/shortage variants to better feed dialogue and UI layers."
      - "Resource dependency matrix will accompany the configs so profession relationships stay inspectable without code dives."
    risks:
      - "Config sprawl could make tuning difficult; plan to split files per profession and add validation tests."
      - "Work order integration with NPC schedules may introduce ordering contention; prototype with explicit claim/confirm steps."
    experiments: []
    open_questions:
      - "Do we model logistics (routes, travel time) before a proper pathfinding system lands?"
      - "Which economy data must persist across saves versus regenerate on load?"
      - "Should shortages automatically spawn new work orders or rely on manual planning initially?"
  - step: "S1.7"
    decisions:
      - "MotivationConfig now loads from config/motivation.toml, providing clamped dopamine ranges, decay, gains, thresholds, and alcohol behaviour."
      - "NpcMotivation reacts to trade, dialogue, and leisure events; mood changes and hangover transitions are logged for observability."
      - "EconomyDependencyMatrix snapshots feed DailyDependencyTracker so food/tool access applies daily bonuses or penalties once the next world day begins."
      - "Leisure rewards stay dopamine-only; dependency satisfaction now depends entirely on profession goods instead of keyword matches."
    risks:
      - "Placeholder dependency matrix only covers food/tools; housing satisfaction will remain missing until Step 7 adds richer configs."
      - "Dependency impacts now queue until the world day advances; stalled clocks would delay wellbeing adjustments."
      - "Alcohol boosts can stack if leisure keywords fire too frequently; tuning keywords or cooldowns may be necessary once more activities exist."
    experiments:
      - "Trialled reduced task rewards during intoxication/hangover to simulate quality penalties; keep adjusting multipliers as professions diversify."
    open_questions:
      - "Where should mood state influence schedules or dialogue tone first (e.g., idle chatter vs. work order selection)?"
      - "Should dependency satisfaction surface in UI alongside dopamine graphs before persistence work begins?"
  - step: "S1.8"
    decisions:
      - "DialogueTelemetryLog mirrors the in-memory buffer to logs/dialogue_history.jsonl with JSONL entries for responses and failures."
      - "Telemetry flushing occurs after each queue run, ensuring the persisted log matches what UI systems observe."
      - "logs/ is ignored via .gitignore so local dialogue history never leaks into commits."
    risks:
      - "JSONL history can grow indefinitely; add rotation or retention controls once sessions extend beyond short spikes."
      - "Writing to disk every response may affect performance on slow media; monitor if dialogue volume increases."
    experiments: []
    open_questions:
      - "Should we provide a config toggle to disable persistence for privacy-sensitive sessions?"
      - "Would summarising the log periodically help bound disk usage without losing conversational context?"
  - step: "S1.9"
    decisions:
      - "Revalidated cargo fmt/clippy/check on the current toolchain before starting the cleanup series."
      - "Documented module responsibilities (core, world, npc, dialogue, economy) to anchor future refactors."
      - "Logged the missing Wayland development headers so hosted environments explain clippy failures."
    risks:
      - "Baseline still depends on local tooling; automated runs will keep failing until libwayland-dev is provisioned."
      - "Responsibility map can drift quickly if not revisited after major feature work."
    experiments: []
    open_questions:
      - "Should we script the responsibility snapshot so future refactors can regenerate it automatically?"
  - step: "S1.10"
    decisions:
      - "Centralised OpenAI defaults (model, timeout, tokens, temperature) inside broker/config to keep overrides consistent."
      - "Captured trade placeholder offsets and locomotion tolerances as constants instead of inline literals."
      - "Surfaced dopamine thresholds and other tunables in README/TASK.md for easier tuning by designers."
    risks:
      - "Constants may diverge from config values if future contributors bypass the documented knobs."
      - "Large const blocks can become unwieldy; consider moving to dedicated config files when more professions arrive."
    experiments:
      - "Compared placeholder offsets in-scene after centralisation to ensure visuals did not shift unexpectedly."
    open_questions:
      - "Do we migrate more of the dialogue prompts into external templates alongside these constants?"
  - step: "S1.11"
    decisions:
      - "Split economy systems into spawning/day_prep/task_execution/dialogue modules with a re-exporting mod.rs."
      - "Broke the dialogue broker into mod/config/openai so HTTP wiring is isolated from the trait surface."
      - "Left public APIs unchanged by re-exporting previous symbols to avoid churn downstream."
    risks:
      - "More modules increases maintenance overhead if ownership boundaries blur; keep READMEs current."
      - "Refactor could hide subtle ordering assumptions; continue to review system scheduling when adding features."
    experiments:
      - "Checked compile times before/after split to ensure module granularity did not regress builds."
    open_questions:
      - "Should spawning/day_prep/task_execution eventually live under their own namespace (e.g., planning::systems)?"
  - step: "S1.12"
    decisions:
      - "Enabled `-D dead_code` during clippy to catch leftovers immediately after modularisation."
      - "Removed unused helpers and legacy imports across economy/dialogue while verifying telemetry pathways."
      - "Kept explicit tests/logs for motivation and trade pipelines to guard against silent regressions."
    risks:
      - "Future feature flags might reintroduce conditional dead code; ensure new stubs are feature-gated instead of left unused."
      - "Reduced scaffolding leaves less buffer for experiments; document any new prototyping hooks promptly."
    experiments: []
    open_questions:
      - "Can we automate dead code checks in CI once the Wayland dependency issue is fixed?"
  - step: "S1.13"
    decisions:
      - "Introduced `DialogueBrokerStatus` so the game exposes whether OpenAI is running in live or fallback mode via startup logs, telemetry, and UI resources."
      - "Recorded broker status snapshots inside `logs/dialogue_history.jsonl`, giving offline tooling a history of mode changes alongside responses/failures."
      - "Bound the `F7` hotkey to a dialogue probe that sends a canned prompt through the queue using the first available NPC identity for quick end-to-end smoke tests."
      - "Automatically load secrets from `secrets.env` (when present) before launching the Bevy app so local API keys do not need to be exported manually."
    risks:
      - "Probe currently picks the first NPC; if no villagers spawn yet the request is skipped and may confuse new users until more robust targeting exists."
      - "Status snapshot is captured at startup; dynamic recovery from fallback would require refreshing the resource if we add reconnection logic."
    experiments:
      - "Verified telemetry log entries render `broker_status` events prior to responses, confirming JSON schema updates remain backward compatible."
    open_questions:
      - "Should we expose a UI toggle to trigger dialogue probes without relying on a keyboard shortcut?"
      - "Do we want automated retries that can flip the broker from fallback to live mid-session once credentials are supplied?"
  - step: "S1.16a"
    decisions:
      - "FINAL IMPLEMENTATION: World-space Text2d entities with billboard rotation, positioned via Transform at NPC 3D coordinates."
      - "Initial attempt used screen-space UI NodeBundle with camera.world_to_viewport(), but user feedback indicated bubbles felt disconnected and hard to associate with speakers."
      - "Converted to Text2d + Transform in world space with billboard rotation (Y-axis only, no roll) to always face camera."
      - "Each NPC has at most one bubble tracked in SpeechBubbleTracker to prevent overlap and simplify updates."
      - "Bubble position updated every frame to NPC.translation + Y offset (2.5 units above head in world space)."
      - "Settings (lifetime 10s, fade 2s, max distance 25u, font size 15pt) exposed via SpeechBubbleSettings resource."
      - "Font size reduced to 15pt (25% smaller than original 20pt) per user request for less screen clutter."
      - "Camera setup fix: Text2d requires Camera2d to render. Camera2d configured with order: 1 and ClearColorConfig::None to render on top of Camera3d (order: 0) without clearing the 3D scene. Eliminates camera order ambiguity and flickering."
    risks:
      - "Billboard rotation + position updates run every frame per bubble; acceptable for current NPC count but may need batching at scale."
      - "Text2d renders plain white text without background - no bubble background implemented, just alpha-faded text."
      - "No text wrapping implemented; long dialogue displays on single line which may be hard to read at distance."
      - "Billboard rotation uses Quat::from_rotation_arc(Vec3::NEG_Z, forward) - may have readability issues at extreme camera angles."
    experiments:
      - "Attempted screen-space UI approach first (NodeBundle + world_to_viewport) - worked technically but felt spatially wrong."
      - "World-space Text2d with billboard rotation provides natural spatial relationship - bubbles stay 'glued' to NPCs in 3D space."
      - "Verified fade-out effect using lifetime.remaining_secs() for smooth alpha transitions during final 2 seconds."
      - "Distance culling via Visibility::Hidden works correctly for bubbles beyond max_display_distance."
      - "Researched Bevy 0.17 camera ordering: cameras with higher order render later (on top). ClearColorConfig::None prevents overlay from clearing underlying render."
    open_questions:
      - "Should we add background sprites (semi-transparent quads) as child entities for traditional bubble appearance?"
      - "Do we need text wrapping now or is single-line acceptable for MVP? User didn't mention readability issues yet."
      - "Should billboard rotation use different algorithm for better readability at extreme camera angles?"
      - "Would background darkening behind text improve readability without full bubble sprites?"

# Accumulates durable lessons and conventions.
long_term:
  architecture:
    - "Hybrid plugin model: explicit deps for core systems; optional plugins share resources/events."
    - "Keep files under ~400 lines; split modules when responsibilities diverge."
    - "Document new resources/components in the nearest module README."
  llm:
    - "Token budget: global throttle + per-NPC cooldown with summarised memories."
    - "Prompts rely on NPC dossier + scoped recent context; avoid world-global dumps."
  data:
    - "Configs live in TOML under /config and should support hot reload later."
    - "Persistent state funnels through DbResource to isolate SQLite usage."
  tooling:
    - "Gate optional instrumentation behind feature flags; default binaries stay clean."
    - "Run fmt + clippy + check before merging; note skipped checks as risks."

# Record significant refactors (leave empty array if none yet).
refactors: []

# What failed and why (helps agents avoid repeats).
postmortems:
  - issue: "S1.16a Speech bubble implementation journey: Text2d -> UI -> Text2d + camera ordering fix"
    date: "2025-10-19 to 2025-10-22"
    what_happened: "Three iterations of speech bubble implementation with final camera ordering fix. (1) Text2d with TextLayout issues - never rendered. (2) UI NodeBundle with world_to_viewport - worked but felt spatially wrong. (3) Text2d in world space with billboard rotation - worked but had camera order ambiguity causing flickering. (4) Fixed camera ordering with explicit order values and ClearColorConfig."
    root_cause: "Initial Text2d attempt (iteration 1) failed due to missing TextLayout component and 2D camera overlay confusion. Pivoted to UI approach which worked technically but had poor UX - bubbles felt detached from NPCs during camera movement. User feedback revealed the spatial disconnect issue. Final Text2d approach required Camera2d for rendering, but both Camera2d and Camera3d defaulting to order: 0 caused ambiguity warning and flickering."
    what_we_tried:
      - "Iteration 1: Text2d + Transform with TextLayout::new_with_no_wrap() and 2D camera overlay - never rendered"
      - "Iteration 2: UI NodeBundle + camera.world_to_viewport() for screen-space positioning - worked but felt 'floaty' and disconnected"
      - "Iteration 3: Text2d + Transform in world space with billboard rotation - natural spatial relationship but flickering"
      - "Iteration 4: Camera2d with order: 1 and ClearColorConfig::None - eliminates ambiguity and flickering"
    why_iterations_1_and_2_failed:
      - "Iteration 1: Architectural confusion between 3D camera rendering and 2D camera overlay; never fully debugged Text2d rendering setup"
      - "Iteration 2: Technically correct but poor UX - bubbles locked to screen coordinates made it hard to identify which NPC was speaking"
      - "Iteration 3: Both cameras defaulted to order: 0, causing Bevy to warn about camera order ambiguities and producing flickering text"
    solution: "Final implementation uses Text2d + Transform positioned at NPC world coordinates + Y offset with billboard rotation (Quat::from_rotation_arc on Y-axis only). Camera3d uses default order: 0, Camera2d uses order: 1 with ClearColorConfig::None to render on top without clearing. Bubbles exist as 3D entities that physically follow NPCs in world space."
    lessons:
      - "For speech bubbles, world-space entities with billboard rotation provide better spatial UX than screen-space UI overlays."
      - "Text2d REQUIRES Camera2d to render, even when positioned in 3D world space."
      - "Multiple cameras rendering to same window must have different order values to avoid ambiguity warnings and flickering."
      - "Overlay cameras (higher order) should use ClearColorConfig::None to avoid clearing the underlying scene."
      - "Bevy 0.17 camera ordering: higher order renders later (on top). Default is 0."
      - "User feedback is critical for UX decisions - technical correctness doesn't mean good player experience."
      - "Screen-space UI (world_to_viewport) is great for HUD elements but poor for spatial indicators tied to game objects."
      - "When user says 'it feels weird', investigate the spatial/movement behavior, not just the visual appearance."
      - "User explicitly requested research over guessing - web search for Bevy docs/examples provided the camera ordering solution."

# Documentation index (update paths as modules appear).
  doc_index:
  core: "/src/core/README.md"
  world: "/src/world/README.md"
  npc: "/src/npc/README.md"
  dialogue: "/src/dialogue/README.md"
  economy: "/src/economy/README.md"
  save: "/src/save/README.md"
  ui: "/src/ui/README.md"
  weather: "/src/weather/README.md"
